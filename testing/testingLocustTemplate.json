{
    "status": "Completed",
    "result": "{\"uuid\": \"apple\", \"filename\": \"test_diagram.png\", \"template\": {\"AWSTemplateFormatVersion\": \"2010-09-09\", \"Description\": \"CloudFormation Template for test_diagram.png\", \"Conditions\": \"\\n  VersioningEnabledForMyBucket1: !Equals [!Ref EnableVersioningForMyBucket1, true]\\n  VersioningEnabledForMyBucket2: !Equals [!Ref EnableVersioningForMyBucket2, true]\\n\\n\\n\\n\\n\\n  VersioningEnabledForMyBucket3: !Equals [!Ref EnableVersioningForMyBucket3, true]\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\", \"Parameters\": \"\\n  BucketNameForMyBucket1:\\n    Description: The name of the S3 bucket\\n    Type: String\\n  EnableVersioningForMyBucket1:\\n    Description: Enable versioning for S3 buckets\\n    Type: String\\n    Default: false\\n    AllowedValues: [true, false]\\n  BucketNameForMyBucket2:\\n    Description: The name of the S3 bucket\\n    Type: String\\n  EnableVersioningForMyBucket2:\\n    Description: Enable versioning for S3 buckets\\n    Type: String\\n    Default: false\\n    AllowedValues: [true, false]\\n  DynamoDBTableNameForMyTable1:\\n    Type: String\\n    Default: \\\"MyTable1\\\"\\n    Description: \\\"The name of the DynamoDB table for MyTable1.\\\"\\n\\n  GraphQLApiNameForMyGraphQLApi1:\\n    Type: String\\n    Default: \\\"MyGraphQLApi1\\\"\\n    Description: \\\"The name of the AppSync GraphQL API for MyGraphQLApi1.\\\"\\n\\n  HostedZoneIdForMyRecordSet1:\\n    Type: String\\n    Description: The Route 53 Hosted Zone ID for your domain for MyRecordSet1\\n\\n\\n  GraphQLApiNameForMyGraphQLApi2:\\n    Type: String\\n    Default: \\\"MyGraphQLApi2\\\"\\n    Description: \\\"The name of the AppSync GraphQL API for MyGraphQLApi2.\\\"\\n\\n  BucketNameForMyBucket3:\\n    Description: The name of the S3 bucket\\n    Type: String\\n  EnableVersioningForMyBucket3:\\n    Description: Enable versioning for S3 buckets\\n    Type: String\\n    Default: false\\n    AllowedValues: [true, false]\\n  ClusterNameForMyCluster1:\\n    Type: String\\n    Default: \\\"MyCluster1\\\"\\n    Description: \\\"The name of the MSK cluster for MyCluster1.\\\"\\n  BrokerInstanceTypeForMyCluster1:\\n    Type: String\\n    Default: \\\"kafka.m5.large\\\"\\n    Description: \\\"The instance type for the Kafka brokers for MyCluster1.\\\"\\n  NumberOfBrokerNodesForMyCluster1:\\n    Type: Number\\n    Default: 3\\n    Description: \\\"The number of broker nodes in the cluster for MyCluster1.\\\"\\n\\n\\n  ApiKeyExpiryForMyApiKey1:\\n    Type: Number\\n    Description: \\\"Unix timestamp when the API key should expire for MyApiKey1.\\\"\\n    Default: 1700889600\\n\\n\\n\\n\\n\\n  ApiKeyExpiryForMyApiKey2:\\n    Type: Number\\n    Description: \\\"Unix timestamp when the API key should expire for MyApiKey2.\\\"\\n    Default: 1700889600\\n\\n\\n\\n  DomainNameForMyDomainName1:\\n    Type: String\\n    Description: The domain name to use for the API for MyDomainName1\\n\\n  SubnetCidrBlockForMySubnet1:\\n    Description: The CIDR block for the new subnet\\n    Type: String\\n    Default: 10.0.1.0/24\\n    AllowedPattern: '^(([0-9]{1,3})\\\\.){3}[0-9]{1,3}/([0-9]|[1-2][0-9]|3[0-2])$'\\n    ConstraintDescription: Must be a valid CIDR block.\\n  AvailabilityZoneForMySubnet1:\\n    Description: The Availability Zone for the subnet\\n    Type: String\\n    Default: us-east-1a  # Replace with your desired AZ\\n\\n\\n\\n  VPCCidrBlockForMyVPC1:\\n    Description: The CIDR block for the VPC\\n    Type: String\\n    Default: 10.0.0.0/16\\n    AllowedPattern: '^(([0-9]{1,3})\\\\.){3}[0-9]{1,3}/([0-9]|[1-2][0-9]|3[0-2])$'\\n    ConstraintDescription: Must be a valid CIDR block.\\n\", \"Resources\": \"\\n  MyFunction1:\\n    Type: 'AWS::Lambda::Function'\\n    Properties:\\n      FunctionName: MySimpleFunctionForMyFunction1\\n      Handler: index.handler\\n      Role: !GetAtt MyRoleForLambda1.Arn\\n      Code:\\n        ZipFile: |\\n          def handler(event, context):\\n            return {\\n              'statusCode': 200,\\n              'body': 'Hello, World!'\\n            }\\n      Runtime: python3.9\\n      Timeout: 10\\n  MyBucket1:\\n    Type: 'AWS::S3::Bucket'\\n    Properties:\\n      BucketName: !Ref BucketNameForMyBucket1\\n      VersioningConfiguration:\\n        Status: !If \\n          - VersioningEnabledForMyBucket1 \\n          - Enabled \\n          - Suspended\\n  MyBucket2:\\n    Type: 'AWS::S3::Bucket'\\n    Properties:\\n      BucketName: !Ref BucketNameForMyBucket2\\n      VersioningConfiguration:\\n        Status: !If \\n          - VersioningEnabledForMyBucket2 \\n          - Enabled \\n          - Suspended\\n  MyTable1:\\n    Type: AWS::DynamoDB::Table\\n    Properties:\\n      TableName: !Ref DynamoDBTableNameForMyTable1\\n      AttributeDefinitions:\\n        - AttributeName: id\\n          AttributeType: S\\n      KeySchema:\\n        - AttributeName: id\\n          KeyType: HASH\\n      BillingMode: PAY_PER_REQUEST\\n  MyGraphQLApi1:\\n    Type: AWS::AppSync::GraphQLApi\\n    Properties:\\n      Name: !Ref GraphQLApiNameForMyGraphQLApi1\\n      AuthenticationType: API_KEY\\n      XrayEnabled: true\\n\\n  MyRecordSet1:\\n    Type: AWS::Route53::RecordSet\\n    Properties:\\n      HostedZoneId: !Ref HostedZoneIdForMyRecordSet1\\n      Name: !Ref DomainNameForMyDomainName1\\n      Type: A\\n      AliasTarget:\\n        DNSName: !GetAtt MyDomainName1.RegionalDomainName\\n        HostedZoneId: !GetAtt MyDomainName1.RegionalHostedZoneId\\n\\n  MyDistribution1:\\n    Type: AWS::CloudFront::Distribution\\n    Properties:\\n      DistributionConfig:\\n        Enabled: true\\n        DefaultCacheBehavior:\\n          ViewerProtocolPolicy: redirect-to-https\\n          TargetOriginId: MyRestApi1\\n          ForwardedValues:\\n            QueryString: false\\n          MinTTL: 0\\n          DefaultTTL: 300\\n          MaxTTL: 1200\\n        Origins:\\n          - Id: MyRestApi1\\n            DomainName: !Sub \\\"${MyRestApi1}.execute-api.${AWS::Region}.amazonaws.com\\\"\\n            OriginPath: /prod\\n            CustomOriginConfig:\\n              HTTPPort: 80\\n              HTTPSPort: 443\\n              OriginProtocolPolicy: https-only\\n\\n  MyGraphQLApi2:\\n    Type: AWS::AppSync::GraphQLApi\\n    Properties:\\n      Name: !Ref GraphQLApiNameForMyGraphQLApi2\\n      AuthenticationType: API_KEY\\n      XrayEnabled: true\\n\\n  MyBucket3:\\n    Type: 'AWS::S3::Bucket'\\n    Properties:\\n      BucketName: !Ref BucketNameForMyBucket3\\n      VersioningConfiguration:\\n        Status: !If \\n          - VersioningEnabledForMyBucket3 \\n          - Enabled \\n          - Suspended\\n  MyFunction2:\\n    Type: 'AWS::Lambda::Function'\\n    Properties:\\n      FunctionName: MySimpleFunctionForMyFunction2\\n      Handler: index.handler\\n      Role: !GetAtt MyRoleForLambda1.Arn\\n      Code:\\n        ZipFile: |\\n          def handler(event, context):\\n            return {\\n              'statusCode': 200,\\n              'body': 'Hello, World!'\\n            }\\n      Runtime: python3.9\\n      Timeout: 10\\n  MyCluster1:\\n    Type: AWS::MSK::Cluster\\n    Properties:\\n      ClusterName: !Ref ClusterNameForMyCluster1\\n      KafkaVersion: \\\"3.4.0\\\" # Choose a supported Kafka version\\n      NumberOfBrokerNodes: !Ref NumberOfBrokerNodesForMyCluster1\\n      BrokerNodeGroupInfo:\\n        BrokerAZDistribution: \\\"DEFAULT\\\"\\n        ClientSubnets: !Ref MySubnet1\\n        InstanceType: !Ref BrokerInstanceTypeForMyCluster1\\n      EncryptionInfo:\\n        EncryptionAtRest:\\n          DataVolumeKMSKeyId: \\\"alias/aws/kafka\\\" # Default AWS-managed KMS key\\n        EncryptionInTransit:\\n          ClientBroker: \\\"TLS\\\"\\n          InCluster: true\\n      LoggingInfo:\\n        BrokerLogs:\\n          CloudWatchLogs:\\n            Enabled: true\\n            LogGroup: !Sub \\\"/aws/msk/${ClusterNameForMyCluster1}\\\"\\n          S3:\\n            Enabled: false\\n          Firehose:\\n            Enabled: false\\n\\n  MyFunction3:\\n    Type: 'AWS::Lambda::Function'\\n    Properties:\\n      FunctionName: MySimpleFunctionForMyFunction3\\n      Handler: index.handler\\n      Role: !GetAtt MyRoleForLambda1.Arn\\n      Code:\\n        ZipFile: |\\n          def handler(event, context):\\n            return {\\n              'statusCode': 200,\\n              'body': 'Hello, World!'\\n            }\\n      Runtime: python3.9\\n      Timeout: 10\\n  MyRestApi1:\\n    Type: 'AWS::ApiGateway::RestApi'\\n    Properties:\\n      Name: MyRestApi1\\n      Description: API for my Lambda function MyRestApi1\\n  MyResource1:\\n    Type: 'AWS::ApiGateway::Resource'\\n    Properties:\\n      ParentId: !GetAtt MyRestApi1.RootResourceId\\n      RestApiId: !Ref MyRestApi1\\n      PathPart: hello\\n  MyMethodForLambda1:\\n    Type: 'AWS::ApiGateway::Method'\\n    Properties:\\n      HttpMethod: GET\\n      ResourceId: !Ref MyRestApi1\\n      RestApiId: !Ref MyResource1\\n      AuthorizationType: NONE\\n      Integration:\\n        Type: AWS_PROXY\\n        IntegrationHttpMethod: POST\\n        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${MyFunction1.Arn}/invocations\\n      MethodResponses:\\n        - StatusCode: 200\\n  MyPermission1:\\n    Type: 'AWS::Lambda::Permission'\\n    Properties:\\n      Action: lambda:InvokeFunction\\n      FunctionName: !Ref MyFunction1\\n      Principal: apigateway.amazonaws.com\\n  MyBucketPolicy1:\\n    Type: 'AWS::S3::BucketPolicy'\\n    Properties:\\n      Bucket: !Ref MyBucket1\\n      PolicyDocument:\\n        Version: \\\"2012-10-17\\\"\\n        Statement:\\n          - Effect: \\\"Allow\\\"\\n            Principal: \\\"*\\\"\\n            Action: \\\"s3:GetObject\\\"\\n            Resource: !Sub \\\"${MyBucket1.Arn}/*\\\"\\n            Condition:\\n              Bool:\\n                \\\"aws:SecureTransport\\\": \\\"true\\\"\\n            # Example condition for allowing secure transport only\\n  MyBucketPolicy2:\\n    Type: 'AWS::S3::BucketPolicy'\\n    Properties:\\n      Bucket: !Ref MyBucket2\\n      PolicyDocument:\\n        Version: \\\"2012-10-17\\\"\\n        Statement:\\n          - Effect: \\\"Allow\\\"\\n            Principal: \\\"*\\\"\\n            Action: \\\"s3:GetObject\\\"\\n            Resource: !Sub \\\"${MyBucket2.Arn}/*\\\"\\n            Condition:\\n              Bool:\\n                \\\"aws:SecureTransport\\\": \\\"true\\\"\\n            # Example condition for allowing secure transport only\\n  MyGraphQLSchema1:\\n    Type: AWS::AppSync::GraphQLSchema\\n    Properties:\\n      ApiId: !GetAtt MyGraphQLApi1.ApiId\\n      Definition: |\\n        type Query {\\n          getItem(id: ID!): Item\\n        }\\n        type Mutation {\\n          putItem(id: ID!, name: String!): Item\\n        }\\n        type Item {\\n          id: ID!\\n          name: String\\n        }\\n        schema {\\n          query: Query\\n          mutation: Mutation\\n        }\\n\\n  MyApiKey1:\\n    Type: AWS::AppSync::ApiKey\\n    Properties:\\n      ApiId: !GetAtt MyGraphQLApi1.ApiId\\n      Expires: !Ref ApiKeyExpiryForMyApiKey1\\n\\n  MyGetResolver1:\\n    Type: AWS::AppSync::Resolver\\n    Properties:\\n      ApiId: !GetAtt MyGraphQLApi1.ApiId\\n      FieldName: \\\"getItem\\\"\\n      TypeName: \\\"Query\\\"\\n      DataSourceName: !Ref MyDataSource1\\n      RequestMappingTemplate: |\\n        {\\n          \\\"version\\\": \\\"2017-02-28\\\",\\n          \\\"operation\\\": \\\"GetItem\\\",\\n          \\\"key\\\": {\\n            \\\"id\\\": $util.dynamodb.toDynamoDBJson($ctx.args.id)\\n          }\\n        }\\n      ResponseMappingTemplate: |\\n        $util.toJson($ctx.result)\\n\\n  MyPutResolver1:\\n    Type: AWS::AppSync::Resolver\\n    Properties:\\n      ApiId: !GetAtt MyGraphQLApi1.ApiId\\n      FieldName: \\\"putItem\\\"\\n      TypeName: \\\"Mutation\\\"\\n      DataSourceName: !Ref MyDataSource1\\n      RequestMappingTemplate: |\\n        {\\n          \\\"version\\\": \\\"2017-02-28\\\",\\n          \\\"operation\\\": \\\"PutItem\\\",\\n          \\\"key\\\": {\\n            \\\"id\\\": $util.dynamodb.toDynamoDBJson($ctx.args.id)\\n          },\\n          \\\"attributeValues\\\": {\\n            \\\"name\\\": $util.dynamodb.toDynamoDBJson($ctx.args.name)\\n          }\\n        }\\n      ResponseMappingTemplate: |\\n        $util.toJson($ctx.result)\\n\\n  MyMethodForCloudfront1:\\n    Type: AWS::ApiGateway::Method\\n    Properties:\\n      RestApiId: !Ref MyRestApi1\\n      ResourceId: !Ref MyResource1\\n      HttpMethod: GET\\n      AuthorizationType: NONE\\n      Integration:\\n        Type: MOCK\\n        IntegrationHttpMethod: GET\\n        PassthroughBehavior: WHEN_NO_MATCH\\n        RequestTemplates:\\n          application/json: '{\\\"statusCode\\\": 200}'\\n        IntegrationResponses:\\n          - StatusCode: 200\\n            ResponseTemplates:\\n              application/json: '{\\\"message\\\": \\\"Hello from API Gateway!\\\"}'\\n      MethodResponses:\\n        - StatusCode: 200\\n\\n  MyGraphQLSchema2:\\n    Type: AWS::AppSync::GraphQLSchema\\n    Properties:\\n      ApiId: !GetAtt MyGraphQLApi2.ApiId\\n      Definition: |\\n        type Query {\\n          getItem(id: ID!): Item\\n        }\\n        type Mutation {\\n          putItem(id: ID!, name: String!): Item\\n        }\\n        type Item {\\n          id: ID!\\n          name: String\\n        }\\n        schema {\\n          query: Query\\n          mutation: Mutation\\n        }\\n\\n  MyApiKey2:\\n    Type: AWS::AppSync::ApiKey\\n    Properties:\\n      ApiId: !GetAtt MyGraphQLApi2.ApiId\\n      Expires: !Ref ApiKeyExpiryForMyApiKey2\\n\\n  MyGetResolver2:\\n    Type: AWS::AppSync::Resolver\\n    Properties:\\n      ApiId: !GetAtt MyGraphQLApi2.ApiId\\n      FieldName: \\\"getItem\\\"\\n      TypeName: \\\"Query\\\"\\n      DataSourceName: !Ref MyDataSource1\\n      RequestMappingTemplate: |\\n        {\\n          \\\"version\\\": \\\"2017-02-28\\\",\\n          \\\"operation\\\": \\\"GetItem\\\",\\n          \\\"key\\\": {\\n            \\\"id\\\": $util.dynamodb.toDynamoDBJson($ctx.args.id)\\n          }\\n        }\\n      ResponseMappingTemplate: |\\n        $util.toJson($ctx.result)\\n\\n  MyPutResolver2:\\n    Type: AWS::AppSync::Resolver\\n    Properties:\\n      ApiId: !GetAtt MyGraphQLApi2.ApiId\\n      FieldName: \\\"putItem\\\"\\n      TypeName: \\\"Mutation\\\"\\n      DataSourceName: !Ref MyDataSource2\\n      RequestMappingTemplate: |\\n        {\\n          \\\"version\\\": \\\"2017-02-28\\\",\\n          \\\"operation\\\": \\\"PutItem\\\",\\n          \\\"key\\\": {\\n            \\\"id\\\": $util.dynamodb.toDynamoDBJson($ctx.args.id)\\n          },\\n          \\\"attributeValues\\\": {\\n            \\\"name\\\": $util.dynamodb.toDynamoDBJson($ctx.args.name)\\n          }\\n        }\\n      ResponseMappingTemplate: |\\n        $util.toJson($ctx.result)\\n\\n  MyBucketPolicy3:\\n    Type: 'AWS::S3::BucketPolicy'\\n    Properties:\\n      Bucket: !Ref MyBucket3\\n      PolicyDocument:\\n        Version: \\\"2012-10-17\\\"\\n        Statement:\\n          - Effect: \\\"Allow\\\"\\n            Principal: \\\"*\\\"\\n            Action: \\\"s3:GetObject\\\"\\n            Resource: !Sub \\\"${MyBucket3.Arn}/*\\\"\\n            Condition:\\n              Bool:\\n                \\\"aws:SecureTransport\\\": \\\"true\\\"\\n            # Example condition for allowing secure transport only\\n  MyResource2:\\n    Type: 'AWS::ApiGateway::Resource'\\n    Properties:\\n      ParentId: !GetAtt MyRestApi1.RootResourceId\\n      RestApiId: !Ref MyRestApi1\\n      PathPart: hello\\n  MyMethodForLambda2:\\n    Type: 'AWS::ApiGateway::Method'\\n    Properties:\\n      HttpMethod: GET\\n      ResourceId: !Ref MyRestApi1\\n      RestApiId: !Ref MyResource2\\n      AuthorizationType: NONE\\n      Integration:\\n        Type: AWS_PROXY\\n        IntegrationHttpMethod: POST\\n        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${MyFunction2.Arn}/invocations\\n      MethodResponses:\\n        - StatusCode: 200\\n  MyPermission2:\\n    Type: 'AWS::Lambda::Permission'\\n    Properties:\\n      Action: lambda:InvokeFunction\\n      FunctionName: !Ref MyFunction2\\n      Principal: apigateway.amazonaws.com\\n  MyResource3:\\n    Type: 'AWS::ApiGateway::Resource'\\n    Properties:\\n      ParentId: !GetAtt MyRestApi1.RootResourceId\\n      RestApiId: !Ref MyRestApi1\\n      PathPart: hello\\n  MyMethodForLambda3:\\n    Type: 'AWS::ApiGateway::Method'\\n    Properties:\\n      HttpMethod: GET\\n      ResourceId: !Ref MyRestApi1\\n      RestApiId: !Ref MyResource3\\n      AuthorizationType: NONE\\n      Integration:\\n        Type: AWS_PROXY\\n        IntegrationHttpMethod: POST\\n        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${MyFunction3.Arn}/invocations\\n      MethodResponses:\\n        - StatusCode: 200\\n  MyPermission3:\\n    Type: 'AWS::Lambda::Permission'\\n    Properties:\\n      Action: lambda:InvokeFunction\\n      FunctionName: !Ref MyFunction3\\n      Principal: apigateway.amazonaws.com\\n  MyRoleForLambda1:\\n    Type: 'AWS::IAM::Role'\\n    Properties:\\n      AssumeRolePolicyDocument:\\n        Version: '2012-10-17'\\n        Statement:\\n          - Effect: Allow\\n            Principal:\\n              Service: lambda.amazonaws.com\\n            Action: sts:AssumeRole\\n      Policies:\\n        - PolicyName: LambdaBasicExecutionForMyRoleForLambda1\\n          PolicyDocument:\\n            Version: '2012-10-17'\\n            Statement:\\n              - Effect: Allow\\n                Action:\\n                  - logs:CreateLogGroup\\n                  - logs:CreateLogStream\\n                  - logs:PutLogEvents\\n                Resource: '*'\\n  MyDomainName1:\\n    Type: AWS::ApiGateway::DomainName\\n    Properties:\\n      DomainName: !Ref DomainNameForMyDomainName1\\n      RegionalCertificateArn: !Ref MyCertificate1\\n      EndpointConfiguration:\\n        Types:\\n          - REGIONAL\\n\\n  MySubnet1:\\n    Type: 'AWS::EC2::Subnet'\\n    Properties:\\n      VpcId: !Ref MyVPC1\\n      CidrBlock: !Ref SubnetCidrBlockForMySubnet1\\n      AvailabilityZone: !Ref AvailabilityZoneForMySubnet1\\n      MapPublicIpOnLaunch: true  # Set to true if you want instances to have public IPs by default\\n      Tags:\\n        - Key: Name\\n          Value: MySubnet1\\n  MyDataSource1:\\n    Type: AWS::AppSync::DataSource\\n    Properties:\\n      ApiId: !GetAtt MyGraphQLApi1.ApiId\\n      Name: \\\"MyDataSource1\\\"\\n      Type: \\\"AMAZON_DYNAMODB\\\"\\n      DynamoDBConfig:\\n        TableName: !Ref MyTable1\\n        AwsRegion: !Ref \\\"AWS::Region\\\"\\n      ServiceRoleArn: !GetAtt MyRoleForAppSyncService1.Arn\\n\\n  MyDataSource2:\\n    Type: AWS::AppSync::DataSource\\n    Properties:\\n      ApiId: !GetAtt MyGraphQLApi2.ApiId\\n      Name: \\\"MyDataSource2\\\"\\n      Type: \\\"AMAZON_DYNAMODB\\\"\\n      DynamoDBConfig:\\n        TableName: !Ref MyTable1\\n        AwsRegion: !Ref \\\"AWS::Region\\\"\\n      ServiceRoleArn: !GetAtt MyRoleForAppSyncService1.Arn\\n\\n  MyCertificate1:\\n    Type: AWS::CertificateManager::Certificate\\n    Properties:\\n      DomainName: !Ref DomainNameForMyDomainName1\\n      ValidationMethod: DNS\\n\\n  MyVPC1:\\n    Type: 'AWS::EC2::VPC'\\n    Properties:\\n      CidrBlock: !Ref VPCCidrBlockForMyVPC1\\n      EnableDnsSupport: true\\n      EnableDnsHostnames: true\\n      Tags:\\n        - Key: Name\\n          Value: MyVPC1\\n  MyRoleForAppSyncService1:\\n    Type: AWS::IAM::Role\\n    Properties:\\n      AssumeRolePolicyDocument:\\n        Version: \\\"2012-10-17\\\"\\n        Statement:\\n          - Effect: Allow\\n            Principal:\\n              Service:\\n                - appsync.amazonaws.com\\n            Action:\\n              - \\\"sts:AssumeRole\\\"\\n      Policies:\\n        - PolicyName: \\\"AppSyncDynamoDBAccessForMyRoleForAppSyncService1\\\"\\n          PolicyDocument:\\n            Version: \\\"2012-10-17\\\"\\n            Statement:\\n              - Effect: Allow\\n                Action:\\n                  - \\\"dynamodb:GetItem\\\"\\n                  - \\\"dynamodb:PutItem\\\"\\n                  - \\\"dynamodb:Query\\\"\\n                  - \\\"dynamodb:Scan\\\"\\n                  - \\\"dynamodb:UpdateItem\\\"\\n                Resource: !GetAtt MyTable1.Arn\\n\", \"Outputs\": \"\\n  LambdaFunctionArnForMyFunction1:\\n    Description: The ARN of the Lambda function for MyFunction1\\n    Value: !GetAtt MyFunction1.Arn\\n  S3BucketNameForMyBucket1:\\n    Description: The name of the created S3 bucket for MyBucket1\\n    Value: !Ref MyBucket1\\n  S3BucketArnForMyBucket1:\\n    Description: The ARN of the created S3 bucket for MyBucket1\\n    Value: !GetAtt MyBucket1.Arn\\n  S3BucketNameForMyBucket2:\\n    Description: The name of the created S3 bucket for MyBucket2\\n    Value: !Ref MyBucket2\\n  S3BucketArnForMyBucket2:\\n    Description: The ARN of the created S3 bucket for MyBucket2\\n    Value: !GetAtt MyBucket2.Arn\\n\\n  GraphQLApiUrlForMyGraphQLApi1:\\n    Description: \\\"The URL endpoint of the AppSync GraphQL API for MyGraphQLApi1\\\"\\n    Value: !GetAtt MyGraphQLApi1.GraphQLUrl\\n\\n  CloudFrontDomainNameForMyDistribution1:\\n    Description: Domain name of the CloudFront distribution for MyDistribution1\\n    Value: !GetAtt MyDistribution1.DomainName\\n  GraphQLApiUrlForMyGraphQLApi2:\\n    Description: \\\"The URL endpoint of the AppSync GraphQL API for MyGraphQLApi2\\\"\\n    Value: !GetAtt MyGraphQLApi2.GraphQLUrl\\n  S3BucketNameForMyBucket3:\\n    Description: The name of the created S3 bucket for MyBucket3\\n    Value: !Ref MyBucket3\\n  S3BucketArnForMyBucket3:\\n    Description: The ARN of the created S3 bucket for MyBucket3\\n    Value: !GetAtt MyBucket3.Arn\\n  LambdaFunctionArnForMyFunction2:\\n    Description: The ARN of the Lambda function for MyFunction2\\n    Value: !GetAtt MyFunction2.Arn\\n  ClusterArnForMyCluster1:\\n    Description: \\\"The ARN of the MSK Cluster for MyCluster1\\\"\\n    Value: !GetAtt MyCluster1.Arn\\n\\n  LambdaFunctionArnForMyFunction3:\\n    Description: The ARN of the Lambda function for MyFunction3\\n    Value: !GetAtt MyFunction3.Arn\\n  ApiUrlForMyRestApi1:\\n    Description: URL for the API Gateway for MyRestApi1\\n    Value: !Sub \\\"https://${MyRestApi1}.execute-api.${AWS::Region}.amazonaws.com/prod/hello\\\"\\n\\n  ApiKeyForMyApiKey1:\\n    Description: \\\"The API key for accessing the AppSync API for MyApiKey1\\\"\\n    Value: !Ref MyApiKey1\\n\\n\\n\\n\\n\\n  ApiKeyForMyApiKey2:\\n    Description: \\\"The API key for accessing the AppSync API for MyApiKey2\\\"\\n    Value: !Ref MyApiKey2\\n\\n\\n\\n\\n  SubnetId:\\n    Description: The ID of the created subnet for MySubnet1\\n    Value: !Ref MySubnet1\\n\\n\\n\\n  VPCId:\\n    Description: The ID of the created VPC for MyVPC1\\n    Value: !Ref MyVPC1\\n\"}}"
}